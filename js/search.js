// When the user clicks on the search box, we want to toggle the search dropdown
function displayToggleSearch(e) {
  e.preventDefault();
  e.stopPropagation();

  closeDropdownSearch(e);
  
  if (idx === null) {
    console.log("Building search index...");
    prepareIdxAndDocMap();
    console.log("Search index built.");
  }
  const dropdown = document.querySelector("#search-dropdown-content");
  if (dropdown) {
    if (!dropdown.classList.contains("show")) {
      dropdown.classList.add("show");
    }
    document.addEventListener("click", closeDropdownSearch);
    document.addEventListener("keydown", searchOnKeyDown);
    document.addEventListener("keyup", searchOnKeyUp);
  }
}

//We want to prepare the index only after clicking the search bar
var idx = null
const docMap = new Map()

function prepareIdxAndDocMap() {
  const docs = [  
    {
      "title": "Encoding - http4s - scala - guardrail",
      "url": "/./docs/scala/http4s/dtos.html",
      "content": "guardrail will generate data transfer objects with encoders and decoders for entity bodies of requests and responses, as long as they’re specified by a $ref reference to either in a components section or in a separate file. Data transfer objects will be represented as case classes, while encoders and decoders depend on the framework used. For dropwizard for example, guardrail will generate jackson encoders and decoders, while for http4s, guardrail will create encoders and decoders for circe. When your schemas are defined inline however, guardrail will not build typed DTOs for the schemas, but fall back to a generic json representation. One scenario where this can happen is when your api specification is built as a bundle with swagger-cli. Fortunately, guardrail understands the unbundled representation with ref elements to separate files."
    } ,    
    {
      "title": "Encoding - akka-http - scala - guardrail",
      "url": "/./docs/scala/akka-http/dtos.html",
      "content": "guardrail will generate data transfer objects with encoders and decoders for entity bodies of requests and responses, as long as they’re specified by a $ref reference to either in a components section or in a separate file. Data transfer objects will be represented as case classes, while encoders and decoders depend on the framework used. For dropwizard for example, guardrail will generate jackson encoders and decoders, while for http4s, guardrail will create encoders and decoders for circe. When your schemas are defined inline however, guardrail will not build typed DTOs for the schemas, but fall back to a generic json representation. One scenario where this can happen is when your api specification is built as a bundle with swagger-cli. Fortunately, guardrail understands the unbundled representation with ref elements to separate files."
    } ,    
    {
      "title": "Generating a Server - java - dropwizard - guardrail",
      "url": "/./docs/java/dropwizard/generating-a-server.html",
      "content": "Generating a Server Setup As we saw in Installation, guardrail is run as part of maven. It hooks into the generate-sources goal. This means our generated server and client is always up-to-date with the specfificaion file. Lets take another look at the maven config for guardrail: &lt;plugin&gt; &lt;groupId&gt;dev.guardrail&lt;/groupId&gt; &lt;artifactId&gt;guardrail-maven-plugin_2.12&lt;/artifactId&gt; &lt;version&gt;0.62.0&lt;/version&gt; &lt;executions&gt; &lt;id&gt;generate-simple-server&lt;/id&gt; &lt;!-- to identify this execution. there can be more than one. --&gt; &lt;goals&gt; &lt;goal&gt;generate-sources&lt;/goal&gt; &lt;!-- always hook to generate-sources goal --&gt; &lt;/goals&gt; &lt;configuration&gt; &lt;language&gt;java&lt;/language&gt; &lt;!-- source code language to generate --&gt; &lt;framework&gt;dropwizard&lt;/framework&gt; &lt;!-- framework code to generate --&gt; &lt;kind&gt;server&lt;/kind&gt; &lt;!-- to generate server routes or a http client --&gt; &lt;specPath&gt;simple-spec.yaml&lt;/specPath&gt; &lt;!-- the Swagger/OpenAPI file for input --&gt; &lt;packageName&gt;MyPackage&lt;/packageName&gt; &lt;!-- all generated code will be in this jvm package --&gt; &lt;/configuration&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; NB: if you prefer to use Vavr instead of Java’s standard library collections, see the generic Java instructions for appropriate configuration options. Once configured, you can manually invoke guardrail with mvn generate-sources. Server Handlers, Resources guardrail-generated servers come in two parts: a Resource and a Handler. The Resource contains all the JAX-RS routing logic, accepting a Handler as a definion of the logic to perform for the routes. The Handler is generated as an interface. You will write the implementation of the Handler and pass it to the Resource in the bootstrapping of the Dropwizard service. Consider the sample OpenAPI spec file we saw back in Sample API Specification. That specified one path. When guardrail generates the server components for us, there will be a UserHandler with one method of the following signature: public CompletionStage&lt;GetUserResponse&gt; getUser(String id) Breaking this down, we can see that for us to implement this route, we will be given the id from the path parameter. Give the ID, we will will return a value of type GetUserResponse wrapped in a CompletionStage. The special type GetUserResponse is also generated for us by guardrail. It is our interface to the responses defined in the OpenAPI spec file. Also, guardrail has set us to return a CompletionStage allowing us to compute our result asynchronous. A simple implementation would be: public class SimpleHandlerImpl implements UsersHandler { @Override public CompletionStage&lt;GetUserResponse&gt; getUser(String id) { return CompletableFuture.supplyAsync(() -&gt; { UserAddress address = (new UserAddress.Builder()) .withLine1(\"375 Beale st\") .withLine2(\"San Francisco, CA\") .build(); List&lt;UserAddress&gt; userAddressList = new ArrayList&lt;&gt;(); userAddressList.add(address); User user = (new User.Builder(\"Jane Doe\")) .withUserAddresses(userAddressList) .build(); return GetUserResponse.Ok(user); }); } } Now we can examine the generated Resource. The resource companion class is generated with all the needed JAX-RS routing and parameter validation. In our Dropwizard Application class, where all resources are registerd with jersey, we can create the Resource and pass it our handler. @Override public void run(final demowizardConfiguration configuration, final Environment environment) { environment.jersey().register(new UsersResource(new SimpleHandlerImpl())); } This illistrates that while guardrail has helped us with much of the setup related to Dropwizard, we are still in controll of all the configuration of the Dropwizard service. Only the HTTP edge layer has been automated for us. (See it in action: guardrail-dev/guardrail-sample-maven-dropwizard) Separation of business logic Providing an implementating of a function with a well-defined set of inputs and outputs is natural for any developer. By reducing the scope of the interface a developer writes against, implementations are more clear and concise. Furthermore, by providing business logic as an implementation of an abstract class, unit tests can test the routing layer and business logic independently, by design. API structure slip is impossible As parameters are explicitly provided as arguments to functions in Handlers, any alteration to parameters constitute a new function interface that must be implemented. As a result, if providing an implementation for an externally managed specification, the compiler informs when a previously written function is no longer sufficient. By representing different response codes and structures as members of a sealed trait, it’s impossible to return a structure that violates the specification, even for less frequently used response codes. Finally, describing an endpoint in your specification without providing an implementation for it is a compiler error. This prevents reduction of functionality due to refactors, human error, or miscommunication with other teams. Prev: Sample API specification Next: Generating clients"
    } ,    
    {
      "title": "Generating a Server - http4s - scala - guardrail",
      "url": "/./docs/scala/http4s/generating-a-server.html",
      "content": "Generating a Server guardrail-generated servers come in two parts: a Resource and a Handler. The Resource contains all the routing logic, accepting a Handler as an argument to the route function in order to provide an HTTP service in whichever supported HTTP framework you’re hosting your service in. The following is an example from the http4s server generator: // The `Handler` trait is fully abstracted from the underlying http framework. As a result, with the exception of some // structural alterations (`F[_]` instead of `Future[_]` as the return type) the same handlers can be used with // different `Resource` implementations from different framework generators. This permits greater compatibility between // different frameworks without changing your business logic. trait UserHandler[F[_]] { def createUser(respond: UserResource.CreateUserResponse.type)(body: definitions.User): F[UserResource.CreateUserResponse] def createUsersWithArrayInput(respond: UserResource.CreateUsersWithArrayInputResponse.type)(body: Vector[definitions.User]): F[UserResource.CreateUsersWithArrayInputResponse] def createUsersWithListInput(respond: UserResource.CreateUsersWithListInputResponse.type)(body: Vector[definitions.User]): F[UserResource.CreateUsersWithListInputResponse] def loginUser(respond: UserResource.LoginUserResponse.type)(username: String, password: String): F[UserResource.LoginUserResponse] def logoutUser(respond: UserResource.LogoutUserResponse.type)(): F[UserResource.LogoutUserResponse] def getUserByName(respond: UserResource.GetUserByNameResponse.type)(username: String): F[UserResource.GetUserByNameResponse] def updateUser(respond: UserResource.UpdateUserResponse.type)(username: String, body: definitions.User): F[UserResource.UpdateUserResponse] def deleteUser(respond: UserResource.DeleteUserResponse.type)(username: String): F[UserResource.DeleteUserResponse] } class UserResource[F[_]](mapRoute: (String, Request[F], F[Response[F]]) =&gt; F[Response[F]] = (_: String, _: Request[F], r: F[Response[F]]) =&gt; r)(implicit F: Async[F]) extends Http4sDsl[F] with CirceInstances { def routes(handler: UserHandler[F]): HttpRoutes[F] = HttpRoutes.of { { case req @ POST -&gt; Root / \"v2\" / \"user\" =&gt; mapRoute(\"createUser\", req, { req.attemptAs(createUserDecoder).foldF(err =&gt; err.cause match { case Some(circeErr: io.circe.DecodingFailure) =&gt; Response[F](status = org.http4s.Status.UnprocessableEntity, body = stringEncoder.toEntity(\"The request body was invalid. \" + circeErr.message + \": \" + circeErr.history.mkString(\", \")).body).pure[F] case _ =&gt; err.toHttpResponse[F](req.httpVersion).pure[F] }, body =&gt; handler.createUser(CreateUserResponse)(body) flatMap ({ case CreateUserResponse.Ok =&gt; F.pure(Response[F](status = org.http4s.Status.Ok)) })) }) case req @ POST -&gt; Root / \"v2\" / \"user\" / \"createWithArray\" =&gt; mapRoute(\"createUsersWithArrayInput\", req, { req.attemptAs(createUsersWithArrayInputDecoder).foldF(err =&gt; err.cause match { case Some(circeErr: io.circe.DecodingFailure) =&gt; Response[F](status = org.http4s.Status.UnprocessableEntity, body = stringEncoder.toEntity(\"The request body was invalid. \" + circeErr.message + \": \" + circeErr.history.mkString(\", \")).body).pure[F] case _ =&gt; err.toHttpResponse[F](req.httpVersion).pure[F] }, body =&gt; handler.createUsersWithArrayInput(CreateUsersWithArrayInputResponse)(body) flatMap ({ case CreateUsersWithArrayInputResponse.Ok =&gt; F.pure(Response[F](status = org.http4s.Status.Ok)) })) }) } } `...` } As all parameters are provided as arguments to the function stubs in the trait, there’s no concern of forgetting to extract a query string parameter or introducing a typo in a form parameter name. The routes and resources generated by guardrail can be hooked up into your HTTP4s server like so: import org.http4s.ember.server.EmberServerBuilder class UserImpl extends UserHandler[IO] { /* Your code here */ } val userHandler: UserHandler[IO] = new UserImpl val usersService = new UsersResource[IO]().routes(userHandler) val httpApp = usersService.orNotFound // Same basic server setup as in the http4s quickstart EmberServerBuilder.default[IO] .withHttpApp(httpApp) .build .use(_ =&gt; IO.never) .as(ExitCode.Success) (See it in action: guardrail-dev/guardrail-sample-http4s, guardrail-dev/guardrail-sample-sbt-http4s-zio) Separation of business logic Providing an implementation of a function with a well-defined set of inputs and outputs is natural for any developer. By reducing the scope of the interface a developer writes against, implementations are more clear and concise. Furthermore, by providing business logic as an implementation of an abstract class, unit tests can test the routing layer and business logic independently, by design. API structure slip is impossible As parameters are explicitly provided as arguments to functions in Handlers, any alteration to parameters constitute a new function interface that must be implemented. As a result, if providing an implementation for an externally managed specification, the compiler informs when a previously written function is no longer sufficient. By representing different response codes and structures as members of a sealed trait, it’s impossible to return a structure that violates the specification, even for less frequently used response codes. Finally, describing an endpoint in your specification without providing an implementation for it is a compiler error. This prevents reduction of functionality due to refactors, human error, or miscommunication with other teams. Prev: Sample API specification Next: Generating clients"
    } ,    
    {
      "title": "Generating a Server - akka-http - scala - guardrail",
      "url": "/./docs/scala/akka-http/generating-a-server.html",
      "content": "Generating a Server guardrail-generated servers come in two parts: a Resource and a Handler. The Resource contains all the routing logic, accepting a Handler as an argument to the route function in order to provide an HTTP service in whichever supported HTTP framework you’re hosting your service in. The following is an example from the akka-http server generator: // The `Handler` trait is fully abstracted from the underlying http framework. As a result, with the exception of some // structural alterations (`F[_]` instead of `Future[_]` as the return type) the same handlers can be used with // different `Resource` implementations from different framework generators. This permits greater compatibility between // different frameworks without changing your business logic. trait UserHandler { def createUser(respond: UserResource.CreateUserResponse.type)(body: definitions.User): scala.concurrent.Future[UserResource.CreateUserResponse] def createUsersWithArrayInput(respond: UserResource.CreateUsersWithArrayInputResponse.type)(body: Vector[definitions.User]): scala.concurrent.Future[UserResource.CreateUsersWithArrayInputResponse] def createUsersWithListInput(respond: UserResource.CreateUsersWithListInputResponse.type)(body: Vector[definitions.User]): scala.concurrent.Future[UserResource.CreateUsersWithListInputResponse] def loginUser(respond: UserResource.LoginUserResponse.type)(username: String, password: String): scala.concurrent.Future[UserResource.LoginUserResponse] def logoutUser(respond: UserResource.LogoutUserResponse.type)(): scala.concurrent.Future[UserResource.LogoutUserResponse] def getUserByName(respond: UserResource.GetUserByNameResponse.type)(username: String): scala.concurrent.Future[UserResource.GetUserByNameResponse] def updateUser(respond: UserResource.UpdateUserResponse.type)(username: String, body: definitions.User): scala.concurrent.Future[UserResource.UpdateUserResponse] def deleteUser(respond: UserResource.DeleteUserResponse.type)(username: String): scala.concurrent.Future[UserResource.DeleteUserResponse] } object UserResource { def routes(handler: UserHandler)(implicit mat: akka.stream.Materializer): Route = { { path(\"v2\" / \"user\")(post(entity(as[definitions.User](createUserDecoder)).apply(body =&gt; complete(handler.createUser(CreateUserResponse)(body))))) } ~ { path(\"v2\" / \"user\" / \"createWithArray\")(post(entity(as[Vector[definitions.User]](createUsersWithArrayInputDecoder)).apply(body =&gt; complete(handler.createUsersWithArrayInput(CreateUsersWithArrayInputResponse)(body))))) } ~ { path(\"v2\" / \"user\" / \"createWithList\")(post(entity(as[Vector[definitions.User]](createUsersWithListInputDecoder)).apply(body =&gt; complete(handler.createUsersWithListInput(CreateUsersWithListInputResponse)(body))))) } ~ { path(\"v2\" / \"user\" / \"login\")(get((parameter(Symbol(\"username\").as[String](stringyJsonUnmarshaller.andThen(unmarshallJson[String]))) &amp; parameter(Symbol(\"password\").as[String](stringyJsonUnmarshaller.andThen(unmarshallJson[String])))).apply((username, password) =&gt; discardEntity(complete(handler.loginUser(LoginUserResponse)(username, password)))))) } ~ { path(\"v2\" / \"user\" / \"logout\")(get(discardEntity(complete(handler.logoutUser(LogoutUserResponse)())))) } ~ { path(\"v2\" / \"user\" / Segment).apply(username =&gt; get(discardEntity(complete(handler.getUserByName(GetUserByNameResponse)(username))))) } ~ { path(\"v2\" / \"user\" / Segment).apply(username =&gt; put(entity(as[definitions.User](updateUserDecoder)).apply(body =&gt; complete(handler.updateUser(UpdateUserResponse)(username, body))))) } ~ { path(\"v2\" / \"user\" / Segment).apply(username =&gt; delete(discardEntity(complete(handler.deleteUser(DeleteUserResponse)(username))))) } } `...` } As all parameters are provided as arguments to the function stubs in the trait, there’s no concern of forgetting to extract a query string parameter, introducing a typo in a form parameter name, or forgetting to close the bytestream for the streaming HTTP Request. (See it in action: guardrail-dev/guardrail-sample-sbt-akkahttp) Separation of business logic Providing an implementation of a function with a well-defined set of inputs and outputs is natural for any developer. By reducing the scope of the interface a developer writes against, implementations are more clear and concise. Furthermore, by providing business logic as an implementation of an abstract class, unit tests can test the routing layer and business logic independently, by design. API structure slip is impossible As parameters are explicitly provided as arguments to functions in Handlers, any alteration to parameters constitute a new function interface that must be implemented. As a result, if providing an implementation for an externally managed specification, the compiler informs when a previously written function is no longer sufficient. By representing different response codes and structures as members of a sealed trait, it’s impossible to return a structure that violates the specification, even for less frequently used response codes. Finally, describing an endpoint in your specification without providing an implementation for it is a compiler error. This prevents reduction of functionality due to refactors, human error, or miscommunication with other teams. Extracting custom data from a request In some cases, you may wish to extract data from a request and inject it into your handler, without specifying the extracted data in the OpenAPI definition. Common use cases include integrating with existing Directives, accessing underlying data provided by akka-http but without a direct analog in OpenAPI, as well as providing an escape hatch to inject functionality expressed via akka-http’s Directive directly into the Akka HTTP routes generated by guardrail. If using the guardrail CLI, supply --custom-extraction when generating your server in order to get this functionality. Once the feature is enabled, the generated code from the above example is modified to look like this: trait UserHandler[-E] { def createUser(respond: UserResource.CreateUserResponse.type)(body: definitions.User)(extracted: E): scala.concurrent.Future[UserResource.CreateUserResponse] // ... } object UserResource { def routes[E](handler: UserHandler, customExtract: String =&gt; Directive1[E])(implicit mat: akka.stream.Materializer): Route = { // ... } } You may now provide a function that accepts the operationId of the route, and returns a Directive1[E], where, E is an arbitrary type that will be passed through to your handlers. The Directive1[E] will be injected into the generated routes after the path and method Directives. Note: If you have any Directive with an arity different to Directive1 (for instance, Directive0 or Directive5) you must convert it into a Directive1 via myCoolDirective.tmap(Tuple1(_)) or similar. This is done to provide a consistent user experience, without the added complexity of the so-called “magnet pattern”. For example, to extract an X-User-Id header value from an incoming request, your code might look like this: class UserApi extends UserHandler[String] { override def createUser(respond: UserResource.CreateUserResponse.type)(body: definitions.User)(userIdHeader: String): scala.concurrent.Future[UserResource.CreateUserResponse] = { println(s\"The supplied X-User-Id header is: $userIdHeader\") ??? } } val extractXUserId = (operationId: String) =&gt; headerValueByName(\"X-User-Id\") // Directive from Akka HTTP val userRoutes = UserResource.routes(new UserApi, extractXUserId) Because E is an arbitrary type, you may extract anything, including the full HttpRequest itself. Multiple values may be extracted using tuples. If you do not wish to extract anything, perhaps because the Directive acts as a gate which passes some requests and rejects others, simply provide String =&gt; Directive1[Unit] and write your handler implementation to extend Handler[Unit]. Generating test-only (real) server mocks for unit tests Often, we’ll also want to have mock HTTP clients for use in unit tests. Mocking requires stringent adherence to the specification, otherwise our mock clients are unrepresentative of the production systems they are intending to mock. The following is an example of a “mock” HTTP Client generated by guardrail; it speaks real HTTP, though doesn’t need to bind to a port in order to run. This permits parallelized tests to be run without concern of port contention. val userRoutes: Route = UserResource.routes(new UserHandler { override def getUserByName(respond: UserResource.getUserByNameResponse.type)(username: String): scala.concurrent.Future[UserResource.getUserByNameResponse] = { if (username == \"foo\") { Future.successful(respond.OK(User(id=Some(1234L), username=Some(\"foo\")))) } else { Future.successful(respond.NotFound) } } }) val userHttpClient: HttpRequest =&gt; Future[HttpResponse] = Route.toFunction(userRoutes) val userClient: UserClient = UserClient.httpCLient(userHttpClient) val getUserResponse: EitherT[Future, Either[Throwable, HttpResponse], User] = userClient.getUserByName(\"foo\").map(_.fold(user =&gt; user)) val user: User = getUserResponse.value.futureValue.right.value // Unwraps `User(id=Some(1234L), username=Some(\"foo\"))` using scalatest's `ScalaFutures` and `EitherValues` unwrappers. This strategy of mocking ensures we follow the spec, even when the specification changes. This means not only more robust tests, but also tests that communicate failures via compiler errors instead of at runtime. Having a clear separation of where errors can come from permits trusting our tests more. If the tests compile, any and all errors that occur are in the domain of business logic. One other strategy for testing non-guardrail generated clients is to bind userRoutes from above to a port, run tests that use hand-rolled or vendor-supplied HTTP clients, then unbind the port when the test ends: val binding: ServerBinding = Http().bindAndHandle(userRoutes, \"localhost\", 1234).futureValue // run tests binding.unbind().futureValue A note about scalatest integration akka-http The default ExceptionHandler in akka-http swallows exceptions, so if you intend to fail() tests from inside guardrail-generated HTTP Servers, you’ll likely want to have the following implicit in scope: implicit def exceptionHandler: ExceptionHandler = new ExceptionHandler { def withFallback(that: ExceptionHandler): ExceptionHandler = this def seal(settings: RoutingSettings): ExceptionHandler = this def isDefinedAt(error: Throwable) = error.isInstanceOf[org.scalatest.TestFailedException] def apply(error: Throwable) = throw error } This passes all TestFailedExceptions through to the underlying infrastructure. In our tests, when we call: val userClient: UserClient = UserClient.httpCLient(userHttpClient) val getUserResponse: EitherT[Future, Either[Throwable, HttpResponse], User] = userClient.getUserByName(\"foo\") val user: User = getUserResponse.map(_.fold(user =&gt; user)).value.futureValue.right.value futureValue will raise the TestFailedException with the relevant stack trace. Prev: Sample API specification Next: Generating clients"
    } ,    
    {
      "title": "Generating Clients - java - dropwizard - guardrail",
      "url": "/./docs/java/dropwizard/generating-clients.html",
      "content": "To generate client code with maven please include following plugin to your pom.xml: &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;dev.guardrail&lt;/groupId&gt; &lt;artifactId&gt;guardrail-maven-plugin_2.12&lt;/artifactId&gt; &lt;version&gt;0.62.0&lt;/version&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;generate-app-server&lt;/id&gt; &lt;goals&gt; &lt;goal&gt;generate-sources&lt;/goal&gt; &lt;/goals&gt; &lt;configuration&gt; &lt;language&gt;java&lt;/language&gt; &lt;framework&gt;dropwizard&lt;/framework&gt; &lt;kind&gt;client&lt;/kind&gt; &lt;specPath&gt;spec.oas3.yaml&lt;/specPath&gt; &lt;packageName&gt;demowizard.client.generated&lt;/packageName&gt; &lt;/configuration&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; (...) &lt;/plugins&gt; &lt;/build&gt; For JDK9+ you also need to add javax.annotation:javax.annotation-api dependency: &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;javax.annotation&lt;/groupId&gt; &lt;artifactId&gt;javax.annotation-api&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; (See it in action: guardrail-dev/guardrail-sample-maven-dropwizard)"
    } ,    
    {
      "title": "Generating Clients - http4s - scala - guardrail",
      "url": "/./docs/scala/http4s/generating-clients.html",
      "content": "Generating clients As we’ve seen in Generating a Server, guardrail-generated servers establish a mapping between our business logic and a cordoned off subset of HTTP. This permits us to focus on our business logic, without getting overloaded with the complexities of managing such a large protocol. The same is true with guardrail generated HTTP Clients: from a consumer’s standpoint, HTTP calls should look like regular function calls, accepting domain-specific arguments and producing domain-specific results. By generating minimal clients that only have enough business knowledge to map domain types to and from HTTP, opportunities for logical errors are effectively removed. While this does not eliminate logical errors entirely, establishing a firm boundary between the underlying protocol and hand-written code drastically reduces the scope of possible bugs. The following is an example from the http4s client generator: // Two constructors are provided, one accepting the `httpClient` and `Async` // implicitly, the other accepting an explicit `httpClient`, but still // accepting the `Async` implicitly object UserClient { def apply[F[_]](host: String)(implicit F: Async[F], httpClient: Http4sClient[F]): UserClient[F] = new UserClient[F](host = host)(F = F, httpClient = httpClient) def httpClient[F[_]](httpClient: Http4sClient[F], host: String)(implicit F: Async[F]): UserClient[F] = new UserClient[F](host = host)(F = F, httpClient = httpClient) } class UserClient[F[_]](host: String)(implicit F: Async[F], httpClient: Http4sClient[F]) { val basePath: String = \"/v2\" def createUser(body: definitions.User, headers: List[Header.ToRaw] = List.empty): F[CreateUserResponse] = { val allHeaders: List[org.http4s.Header.ToRaw] = List.empty[Header.ToRaw] ++ headers ++ List[Option[Header.ToRaw]]().flatten val req = Request[F](method = Method.POST, uri = Uri.unsafeFromString(host + basePath + \"/user\"), headers = Headers(allHeaders)).withEntity(body)(createUserEncoder) httpClient.run(req).use({ case _root_.org.http4s.Status.Ok(_) =&gt; F.pure(CreateUserResponse.Ok): F[CreateUserResponse] case resp =&gt; F.raiseError[CreateUserResponse](UnexpectedStatus(resp.status, Method.POST, req.uri)) }) } def createUsersWithArrayInput(body: Vector[definitions.User], headers: List[Header.ToRaw] = List.empty): F[CreateUsersWithArrayInputResponse] = ??? def createUsersWithListInput(body: Vector[definitions.User], headers: List[Header.ToRaw] = List.empty): F[CreateUsersWithListInputResponse] = ??? def loginUser(username: String, password: String, headers: List[Header.ToRaw] = List.empty): F[LoginUserResponse] = ??? def logoutUser(headers: List[Header.ToRaw] = List.empty): F[LogoutUserResponse] = ??? def getUserByName(username: String, headers: List[Header.ToRaw] = List.empty): F[GetUserByNameResponse] = ??? def updateUser(username: String, body: definitions.User, headers: List[Header.ToRaw] = List.empty): F[UpdateUserResponse] = ??? def deleteUser(username: String, headers: List[Header.ToRaw] = List.empty): F[DeleteUserResponse] = ??? } (See it in action: guardrail-dev/guardrail-sample-http4s, guardrail-dev/guardrail-sample-sbt-http4s-zio) Separation of protocol-concerns from API-level concerns As guardrail clients are built on top of any Http4s client type, client configuration is done the same way as you are already familiar with when using Http4s. Check out the docs for Http4s Clients. Prev: Generating a Server"
    } ,    
    {
      "title": "Generating Clients - akka-http - scala - guardrail",
      "url": "/./docs/scala/akka-http/generating-clients.html",
      "content": "Generating clients As we’ve seen in Generating a Server, guardrail-generated servers establish a mapping between our business logic and a cordoned off subset of HTTP. This permits us to focus on our business logic, without getting overloaded with the complexities of managing such a large protocol. The same is true with guardrail generated HTTP Clients: from a consumer’s standpoint, HTTP calls should look like regular function calls, accepting domain-specific arguments and producing domain-specific results. By generating minimal clients that only have enough business knowledge to map domain types to and from HTTP, opportunities for logical errors are effectively removed. While this does not eliminate logical errors entirely, establishing a firm boundary between the underlying protocol and hand-written code drastically reduces the scope of possible bugs. The following is an example from the akka-http client generator: // Two constructors are provided, one accepting the `httpClient`, // `ExecutionContext`, and `Materializer` implicitly, the other accepting // an explicit `httpClient`, but still accepting the `ExecutionContext` and // `Materializer` as implicits. object UserClient { def apply(host: String)(implicit httpClient: HttpRequest =&gt; Future[HttpResponse], ec: ExecutionContext, mat: Materializer): UserClient = new UserClient(host = host)(httpClient = httpClient, ec = ec, mat = mat) def httpClient(httpClient: HttpRequest =&gt; Future[HttpResponse], host: String)(implicit ec: ExecutionContext, mat: Materializer): UserClient = new UserClient(host = host)(httpClient = httpClient, ec = ec, mat = mat) } class UserClient(host: String)(implicit httpClient: HttpRequest =&gt; Future[HttpResponse], ec: ExecutionContext, mat: Materializer) { val basePath: String = \"/v2\" def createUser(body: definitions.User, headers: List[HttpHeader] = Nil): EitherT[Future, Either[Throwable, HttpResponse], CreateUserResponse] = { val allHeaders = headers ++ scala.collection.immutable.Seq[Option[HttpHeader]]().flatten makeRequest(HttpMethods.POST, host + basePath + \"/user\", allHeaders, body, HttpProtocols.`HTTP/1.1`).flatMap(req =&gt; EitherT(httpClient(req).flatMap(resp =&gt; resp.status match { case StatusCodes.OK =&gt; resp.discardEntityBytes().future.map(_ =&gt; Right(CreateUserResponse.OK)) case _ =&gt; FastFuture.successful(Left(Right(resp))) }).recover({ case e: Throwable =&gt; Left(Left(e)) }))) } def createUsersWithArrayInput(body: Vector[definitions.User], headers: List[HttpHeader] = Nil): EitherT[Future, Either[Throwable, HttpResponse], CreateUsersWithArrayInputResponse] = ??? def createUsersWithListInput(body: Vector[definitions.User], headers: List[HttpHeader] = Nil): EitherT[Future, Either[Throwable, HttpResponse], CreateUsersWithListInputResponse] = ??? def loginUser(username: String, password: String, headers: List[HttpHeader] = Nil): EitherT[Future, Either[Throwable, HttpResponse], LoginUserResponse] = ??? def logoutUser(headers: List[HttpHeader] = Nil): EitherT[Future, Either[Throwable, HttpResponse], LogoutUserResponse] = ??? def getUserByName(username: String, headers: List[HttpHeader] = Nil): EitherT[Future, Either[Throwable, HttpResponse], GetUserByNameResponse] = ??? def updateUser(username: String, body: definitions.User, headers: List[HttpHeader] = Nil): EitherT[Future, Either[Throwable, HttpResponse], UpdateUserResponse] = ??? def deleteUser(username: String, headers: List[HttpHeader] = Nil): EitherT[Future, Either[Throwable, HttpResponse], DeleteUserResponse] = ??? } (See it in action: guardrail-dev/guardrail-sample-sbt-akkahttp) Separation of protocol-concerns from API-level concerns As guardrail clients are built on top of the function type HttpRequest =&gt; Future[HttpResponse], client configuration is reduced to function composition. Some ideas: val singleRequestHttpClient = { (req: HttpRequest) =&gt; Http().singleRequest(req) } val retryingHttpClient = { nextClient: (HttpRequest =&gt; Future[HttpResponse]) =&gt; req: HttpRequest =&gt; nextClient(req).flatMap(resp =&gt; if (resp.status.intValue &gt;= 500) nextClient(req) else Future.successful(resp)) } val metricsHttpClient = { nextClient: (HttpRequest =&gt; Future[HttpResponse]) =&gt; req: HttpRequest =&gt; { val resp = nextClient(req) resp.onSuccess { _resp =&gt; trackMetrics(req.uri.path, _resp.status) } resp } } // Track metrics for every request, even retries val retryingMetricsClient1: HttpRequest =&gt; Future[HttpResponse] = retryingHttpClient(metricsHttpClient(singleRequestHttpClient)) // Only track metrics for requests we didn't have to retry val retryingMetricsClient2: HttpRequest =&gt; Future[HttpResponse] = metricsHttpClient(retryingHttpClient(singleRequestHttpClient)) Prev: Generating a Server Next: guardrail Extensions"
    } ,    
    {
      "title": "guardrail extensions - http4s - scala - guardrail",
      "url": "/./docs/scala/http4s/guardrail-extensions.html",
      "content": "guardrail Extensions guardrail has a number of vendor extensions designed to enhance safety and provide more idiomatic generated code. The following table lists all vendor extensions, contexts where they are applicable, and a short description of how to use them effectively. Extension Type Contexts Description x-empty-is-null boolean clients/servers, definitions Instructs the JSON decoder to convert empty strings to null before decoding, causing empty strings to not satisfy the required directive, or being represented as None instead of Some(\"\"). x-file-hash string servers, parameters, file During a streaming file upload, keep track of the file hash in one of the supported file hash types. x-scala-package string clients/servers, paths A dot-separated package segment concatenated to the end of the supplied packageName when generating Scala code. This permits splitting up large specifications into smaller, domain-specific Handlers. See also x-jvm-package. x-java-package string clients/servers, paths A dot-separated package segment concatenated to the end of the supplied packageName when generating Java code. This permits splitting up large specifications into smaller, domain-specific Handlers. See also x-jvm-package. x-jvm-package string clients/servers, paths A dot-separated package segment concatenated to the end of the supplied packageName when generating JVM code. This permits splitting up large specifications into smaller, domain-specific Handlers. Note that x-scala-package and x-java-package take precedence over this property. x-server-raw-response boolean servers, paths Exposes the underlying HTTP framework's response-building infrastructure. Type-safe `respond` wrappers are still generated and supplied, though this escape-hatch is intended to work around bugs in guardrail itself. This is not recommended for long-term use, as no guarantees around compile-time-safe protocol adherence can be made. x-tracing-label string clients/servers, paths When tracing is enabled, override the provided function label with a custom string. This string will be supplied to your supplied trace function in your servers and your supplied traceBuilder in your clients. x-scala-type string definitions, parameters Override the primitive types specified in the OpenAPI specification with a domain-specific type for generated Scala code. This requires the type to have either serializers/deserializers in the underlying JSON framework or HTTP framework. As this is an advanced feature, it may require use of custom imports provided via build tool plugins or at the CLI. x-java-type string definitions, parameters Override the primitive types specified in the OpenAPI specification with a domain-specific type for generated Java code. This requires the type to have either serializers/deserializers in the underlying JSON framework or HTTP framework. As this is an advanced feature, it may require use of custom imports provided via build tool plugins or at the CLI. x-jvm-type string definitions, parameters Override the primitive types specified in the OpenAPI specification with a domain-specific type for generated JVM (Scala and Java) code. This requires the type to have either serializers/deserializers in the underlying JSON framework or HTTP framework. As this is an advanced feature, it may require use of custom imports provided via build tool plugins or at the CLI. x-scala-array-type, x-java-array-type string definitions, parameters Override the generated array type from `Vector` to some custom type. This requires the type to have either serializers/deserializers in the underlying JSON framework or HTTP framework. As this is an advanced feature, it may require use of custom imports provided via build tool plugins or at the CLI. x-scala-map-type, x-java-map-type string definitions, parameters Override the generated map type from `Map` to some custom type. This requires the type to have either serializers/deserializers in the underlying JSON framework or HTTP framework. As this is an advanced feature, it may require use of custom imports provided via build tool plugins or at the CLI. x-scala-class-prefix string clients/servers An arbitrary class name prefix that overrides the default class name when generating Scala code. See also x-jvm-class-prefix. x-java-class-prefix string clients/servers An arbitrary class name prefix that overrides the default class name when generating Java code. See also x-jvm-class-prefix. x-jvm-class-prefix string clients/servers An arbitrary class name prefix that overrides the default class name when generating JVM code. See also x-scala-class-prefix. Prev: Generating clients"
    } ,    
    {
      "title": "guardrail extensions - akka-http - scala - guardrail",
      "url": "/./docs/scala/akka-http/guardrail-extensions.html",
      "content": "guardrail Extensions guardrail has a number of vendor extensions designed to enhance safety and provide more idiomatic generated code. The following table lists all vendor extensions, contexts where they are applicable, and a short description of how to use them effectively. Extension Type Contexts Description x-empty-is-null boolean clients/servers, definitions Instructs the JSON decoder to convert empty strings to null before decoding, causing empty strings to not satisfy the required directive, or being represented as None instead of Some(\"\"). x-file-hash string servers, parameters, file During a streaming file upload, keep track of the file hash in one of the supported file hash types. x-scala-package string clients/servers, paths A dot-separated package segment concatenated to the end of the supplied packageName when generating Scala code. This permits splitting up large specifications into smaller, domain-specific Handlers. See also x-jvm-package. x-java-package string clients/servers, paths A dot-separated package segment concatenated to the end of the supplied packageName when generating Java code. This permits splitting up large specifications into smaller, domain-specific Handlers. See also x-jvm-package. x-jvm-package string clients/servers, paths A dot-separated package segment concatenated to the end of the supplied packageName when generating JVM code. This permits splitting up large specifications into smaller, domain-specific Handlers. Note that x-scala-package and x-java-package take precedence over this property. x-server-raw-response boolean servers, paths Exposes the underlying HTTP framework's response-building infrastructure. Type-safe `respond` wrappers are still generated and supplied, though this escape-hatch is intended to work around bugs in guardrail itself. This is not recommended for long-term use, as no guarantees around compile-time-safe protocol adherence can be made. x-tracing-label string clients/servers, paths When tracing is enabled, override the provided function label with a custom string. This string will be supplied to your supplied trace function in your servers and your supplied traceBuilder in your clients. x-scala-type string definitions, parameters Override the primitive types specified in the OpenAPI specification with a domain-specific type for generated Scala code. This requires the type to have either serializers/deserializers in the underlying JSON framework or HTTP framework. As this is an advanced feature, it may require use of custom imports provided via build tool plugins or at the CLI. x-java-type string definitions, parameters Override the primitive types specified in the OpenAPI specification with a domain-specific type for generated Java code. This requires the type to have either serializers/deserializers in the underlying JSON framework or HTTP framework. As this is an advanced feature, it may require use of custom imports provided via build tool plugins or at the CLI. x-jvm-type string definitions, parameters Override the primitive types specified in the OpenAPI specification with a domain-specific type for generated JVM (Scala and Java) code. This requires the type to have either serializers/deserializers in the underlying JSON framework or HTTP framework. As this is an advanced feature, it may require use of custom imports provided via build tool plugins or at the CLI. x-scala-array-type, x-java-array-type string definitions, parameters Override the generated array type from `Vector` to some custom type. This requires the type to have either serializers/deserializers in the underlying JSON framework or HTTP framework. As this is an advanced feature, it may require use of custom imports provided via build tool plugins or at the CLI. x-scala-map-type, x-java-map-type string definitions, parameters Override the generated map type from `Map` to some custom type. This requires the type to have either serializers/deserializers in the underlying JSON framework or HTTP framework. As this is an advanced feature, it may require use of custom imports provided via build tool plugins or at the CLI. x-scala-class-prefix string clients/servers An arbitrary class name prefix that overrides the default class name when generating Scala code. See also x-jvm-class-prefix. x-java-class-prefix string clients/servers An arbitrary class name prefix that overrides the default class name when generating Java code. See also x-jvm-class-prefix. x-jvm-class-prefix string clients/servers An arbitrary class name prefix that overrides the default class name when generating JVM code. See also x-scala-class-prefix. Prev: Generating clients"
    } ,    
    {
      "title": "Spring MVC - java - guardrail",
      "url": "/./docs/java/spring-mvc/",
      "content": "These docs are under construction! In the meantime, please refer to the dropwizard docs for broad context and getting started. Note that the framework for Spring MVC is \"spring-mvc\", so using that in your Maven, Gradle, or SBT plugin configuration should get you started."
    } ,    
    {
      "title": "dropwizard - java - guardrail",
      "url": "/./docs/java/dropwizard/",
      "content": "Table of Contents What is guardrail Single Point of Truth Unexpected API changes are compiler errors Fewer binary dependencies Installation Sample API specification Generating a Server Setup Server Handlers, Resources Separation of business logic API structure slip is impossible Generating clients Java Dropwizard Support for Dropwizard 1.3 has been available since guardrail v0.45.0. Using guardrail you can generate server definions and http clients."
    } ,    
    {
      "title": "java - guardrail",
      "url": "/./docs/java/",
      "content": "guardrail can generate Java clients and servers for the following frameworks: dropwizard spring-mvc In addition, the Java generation backend supports use of either standard Java collections types (such as java.util.Optional and java.util.Map), or Vavr collections types (such as io.vavr.control.Option and io.vavr.collection.Vector). Vavr’s collection types are more internally consistent and attempt to provide an interface familiar to functional programmers. Scala developers will find their APIs especially familiar. To make use of the Vavr generation, you need to instead use guardrail’s module system. Instead of specifying a framework, instead specify a series of modules that describe the framework, protocol, and collectsions library generators to use. For example, if I were using the guardrail Maven plugin, and wanted to use Vavr with Dropwizard, I’d include in my &lt;configuration&gt;: &lt;modules&gt; &lt;module&gt;java-vavr&lt;/module&gt; &lt;module&gt;jackson&lt;/module&gt; &lt;module&gt;dropwizard&lt;/module&gt; &lt;/module&gt; Currently, Vavr is only supported with the dropwizard framework."
    } ,    
    {
      "title": "akka-http-jackson - scala - guardrail",
      "url": "/./docs/scala/akka-http-jackson/",
      "content": "The akka-http-jackson framework generates the same server and client APIs as the akka-http framework, except that Jackson is used for serialization and deserialization (instead of Circe). Usage-wise, it is very similar to akka-http. Extra information specific to this framework can be found below. guardrail Configuration You can either specify the akka-http-jackson framework, or the akka-http and jackson modules. Prerequisites In addition to the akka-http dependencies, you’ll need the following: com.fasterxml.jackson.core:jackson-core com.fasterxml.jackson.core:jackson-databind com.fasterxml.jackson.core:jackson-annotations com.fasterxml.jackson.datatype:jackson-datatype-jsr310 (only if date and date-time types are used in your spec) com.fasterxml.jackson.module:jackson-module-scala_${scala.compat.version} org.hibernate.validator:hibernate-validator (or org.hibernate:hibernate-validator) While testing has been done with Jackson 2.11.x, older 2.x versions should work as well. Hibernate Validator 5.4.x and 6.0.x have been tested and appear to work. Server and Client Construction When constructing your server routes or client instances, you’ll need implicit ObjectMapper (Jackson) and Validator (Hibernate) instances available. ObjectMapper You must register DefaultScalaModule on your object mapper. If your spec uses date or date-time string formats, you must also register JavaTimeModule. Validator The validator can be constructed in whatever manner you desire. Hibernate is recommended, but guardrail does not currently use any Hibernate-specific annotations; however, it may do so in the future as more strict validations are implemented. Caveat In general, using the Circe-backed akka-http is recommended if you have a choice. However, if you’re required to use Jackson for some reason, this framework is available. It’s also useful if you have a Scala project that needs protocol/model objects, and you need to use Jackson."
    } ,    
    {
      "title": "dropwizard - scala - guardrail",
      "url": "/./docs/scala/dropwizard/",
      "content": "The dropwizard framework generates Scala code for Dropwizard, using Jackson for serialization. Server Generation Prerequisites In addition to standard Dropwizard dependencies, you’ll need: io.dropwizard:dropwizard-forms com.datasift.dropwizard.scala:dropwizard-scala-core com.fasterxml.jackson.datatype:jackson-datatype-jsr310 com.fasterxml.jackson.module:jackson-module-scala_${scala.compat.version} org.typelevel:cats-core_${scala_binary_version} The ScalaBundle from dropwizard-scala should be added in your application’s initialize() method using bootstrap.addBundle(). For each resource generated by guardrail, you’ll need to register it with Jersey in your application’s run() method using environment.jersey.register(). Usage Server usage follows the same pattern as the Scala akka-http framework. You must implement a Handler class for each resource. Each handler method takes a respond parameter, which allows you to easily construct response instances, plus all parameters specified for the method’s underlying operation. The handler should be passed to the resource class upon construction. Custom Types If you need to use a custom type in any guardrail-generated code (via x-scala-type or x-jvm-type), you’ll need to provide implicit GuardrailEncoder, GuardrailDecoder, and GuardrailValidator instances. Usually something like this is all that’s required: implicit val encodeMyType: GuardrailEncoder[MyType] = GuardrailEncoder.instance implicit val decodeMyType: GuardrailDecoder[MyType] = GuardrailDecoder.instance(new TypeReference&lt;MyType&gt;() {}) implicit val validateMyType: GuardrailValidator[MyType] = GuardrailValidator.instance If your type does not work properly with validation for some reason, you can instead use GuardrailValidator.noop. Your custom implicits can be imported by adding a customImport to your guardrail configuration. See the specific plugin documentation for more information. Handling Errors Dropwizard, Jersey, and Jackson do their own validation of input parameters. If validation fails, the resource class method will never be called, and Dropwizard will return a 4xx error with a generic response body. We recommended that you define response codes in your guardrail spec to signal this possibility, and implement and register a Dropwizard ExceptionMapper that outputs response bodies that conform to your spec. In particular, you’ll want to look out for IllegalArgumentException, ValidationException, and subclasses of WebApplicationException that signal 4xx response codes (however, there may be other exceptions thrown). Similarly, Dropwizard can return 5xx responses when the server is overloaded or if there is some other issue. Again, we recommended you specify and handle this properly by including those response codes in your spec, and handling the appropriate exceptions in your exception mapper. We recommend that you avoid throwing exceptions to signal errors, and instead carefully define expected error response codes in your spec. From there, you can use the respond parameter passed to your handler methods to return errors of the proper form. The generated resource methods do handle failed Futures in that they return a generic 500 error with no response body, but that is likely not what your API clients will expect. Client Generation Client generation is not yet implemented."
    } ,    
    {
      "title": "http4s - scala - guardrail",
      "url": "/./docs/scala/http4s/",
      "content": "Table of Contents What is guardrail Single Point of Truth Unexpected API changes are compiler errors Fewer binary dependencies Installation Sample API specification Generating Domain Objects Generating a Server Separation of business logic API structure slip is impossible Generating test-only (real) server mocks for unit tests A note about scalatest integration Generating clients Separation of protocol-concerns from API-level concerns guardrail Extensions"
    } ,    
    {
      "title": "akka-http - scala - guardrail",
      "url": "/./docs/scala/akka-http/",
      "content": "Table of Contents What is guardrail Single Point of Truth Unexpected API changes are compiler errors Fewer binary dependencies Installation Sample API specification Generating Domain Objects Generating a Server Separation of business logic API structure slip is impossible Generating test-only (real) server mocks for unit tests A note about scalatest integration Generating clients Separation of protocol-concerns from API-level concerns guardrail Extensions"
    } ,    
    {
      "title": "Getting started",
      "url": "/./docs/",
      "content": "Getting started: Scala akka-http akka-http-jackson http4s dropwizard Java dropwizard spring-mvc"
    } ,    
    {
      "title": "Home",
      "url": "/./",
      "content": "guardrail is a code generation tool, capable of reading from OpenAPI/Swagger specification files and generating high quality source code for a variety of languages and frameworks. There are plugins available for sbt, maven, gradle, and there’s a manual CLI driver. Additionally, check out the guardrail-sample topic on GitHub for more examples. Consulting: If you need help getting started, getting migrated, or adding features, please contact hello@guardrail.dev."
    } ,    
    {
      "title": "Installation - java - dropwizard - guardrail",
      "url": "/./docs/java/dropwizard/installation.html",
      "content": "Installation guardrail is available as a modular core, with both sbt and Maven integration. The core can also be run as a stand-alone CLI application, with full support for all features. guardrail for Dropwizard is generally set up using the maven plugin. This will generate your server or client at build time. The following is an example invocation in a pom.xml file: &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;dev.guardrail&lt;/groupId&gt; &lt;artifactId&gt;guardrail-maven-plugin_2.12&lt;/artifactId&gt; &lt;version&gt;0.62.0&lt;/version&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;generate-app-server&lt;/id&gt; &lt;goals&gt; &lt;goal&gt;generate-sources&lt;/goal&gt; &lt;/goals&gt; &lt;configuration&gt; &lt;language&gt;java&lt;/language&gt; &lt;framework&gt;dropwizard&lt;/framework&gt; &lt;kind&gt;server&lt;/kind&gt; &lt;specPath&gt;server-spec.yaml&lt;/specPath&gt; &lt;packageName&gt;demowizard.generated&lt;/packageName&gt; &lt;/configuration&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; (...) &lt;/plugins&gt; &lt;/build&gt; For JDK9+ you also need to add javax.annotation:javax.annotation-api dependency: &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;javax.annotation&lt;/groupId&gt; &lt;artifactId&gt;javax.annotation-api&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; Prev: What is guardrail? Next: Sample API specification"
    } ,    
    {
      "title": "Installation - http4s - scala - guardrail",
      "url": "/./docs/scala/http4s/installation.html",
      "content": "Installation guardrail is available as a modular core, with both sbt and Maven integration. The core can also be run as a stand-alone CLI application, with full support for all features. To generate servers or clients using the http4s framework, set http4s as the framework in the generation configuration in either sbt or maven. If compiling with Scala &lt; 2.13.x, you’ll need to enable -Ypartial-unification: scalacOptions += \"-Ypartial-unification\" If compiling with Scala &lt; 2.12.x, you’ll additionally need the -Xexperimental flag: scalacOptions += \"-Xexperimental\" Additionally, you will need to manually include dependencies in your project for the following packages: http4s, dsl, server, and client dependencies http4s-circe for JSON decoding and encoding support circe-generic for JSON decoding and encoding support cats-effect for http4s integration cats-core for http4s integration Versions of these libraries should be picked by checking out the Compatibility Matrix. Prev: What is guardrail? Next: Sample API specification"
    } ,    
    {
      "title": "Installation - akka-http - scala - guardrail",
      "url": "/./docs/scala/akka-http/installation.html",
      "content": "Installation guardrail is available as a modular core, with both sbt and Maven integration. The core can also be run as a stand-alone CLI application, with full support for all features. If compiling with Scala &lt; 2.13.x, you’ll need to enable -Ypartial-unification: scalacOptions += \"-Ypartial-unification\" If compiling with Scala &lt; 2.12.x, you’ll additionally need the -Xexperimental flag: scalacOptions += \"-Xexperimental\" Prev: What is guardrail? Next: Sample API specification"
    } ,      
    {
      "title": "Sample API Specification - java - dropwizard - guardrail",
      "url": "/./docs/java/dropwizard/sample-api-specification.html",
      "content": "Sample API specification The following is a complete, annotated OpenAPI specification file: (guardrail extensions are documented in guardrail Extensions) openapi: 3.0.0 # Version of Swagger/OpenAPI of this file info: # Primarily for consumption by documentation generation tools title: My Service version: 0.1.0 servers: # List of hosts (and ports) where generated clients should connect to - url: http://localhost:1234 paths: # All HTTP Paths are children of this `paths` field \"/user/{id}\": # Paths can have variables in them get: # HTTP Method operationId: getUser # Friendly name, will be the method name in generated clients and servers x-jvm-package: users # Relative package for this client to live in parameters: # All parameters (including path parameters) are listed here. - name: id # Field name, case sensitive in: path # where the parameter will be found. description: The ID of the user # description of the parameter. Not used in guardrail, but other tools may consume it required: true # required fields can not be missing. Optional fields will become `Optional&lt;T&gt;` schema: type: string # One of the primitive types supported in the OpenAPI specification. x-java-type: CustomString # Escape hatch to explicitly introduce a custom type. This is an # advanced technique to introduce completely custom # marshalling/unmarshalling/validation logic. Keep in mind, everyone # else will just see a plain string! responses: # All response codes that are possible for this path are listed here \"200\": # Each HTTP status code is mapped to the corresponding textual representation description: \"\" content: \"application/json\": # the Content-Type of the return value. Java guardrail will use jackson for converting json schema: $ref: \"#/components/schemas/User\" # a reference to elsewhere in this spec for a definition of the response body \"404\": # failure responses must be declared description: Not found # description isn't used by guardrail but is useful to indiciate we return no body for this response components: # reusable sections of the spec can be described under `components` schemas: User: # This identifies a symbolic structure name. Not all names are # translated into classes when rendered, depending on whether they # identify classes with structure, or defer to standard classes # like `Vector` for `type: array`. type: object # will generate a `User` case class in the `definitions` package required: # A list of which parameters are required. This is enforced for # clients by having non-optional parameters, and for servers by # ensuring all submitted data to the endpoint validates the schema # before getting to your `Handler` function. - id # These names must match the `properties` names exactly - user_addresses properties: id: # Case matters for `properties`! A heuristic determines whether it's # possible to translate a property name into a unique, non-reserved # camelCase identifier. type: string # One of the primitive types supported in the OpenAPI specification. user_addresses: # Similar to `id`, though `user_addresses` can be safely transformed into # `userAddress`, so this is done to expose idiomatic Java. The underlying # marshallers and unmarshallers maintain this mapping for you though, # so no chance of protocol violations. $ref: \"#/components/schemas/UserAddresses\" # Ensures that the type of `userAddress` will be `List&lt;UserAddress&gt;` UserAddresses: type: array items: $ref: \"#/components/schemas/UserAddress\" # `items` is a special key for `type: array`, identifying the structure of the # sequence members UserAddress: type: object properties: line1: type: string line2: type: string line3: type: string Prev: Installation Next: Generating a Server"
    } ,    
    {
      "title": "Sample API Specification - http4s - scala - guardrail",
      "url": "/./docs/scala/http4s/sample-api-specification.html",
      "content": "Sample API specification The following is a complete, annotated OpenAPI specification file: (guardrail extensions are documented in guardrail Extensions) swagger: \"2.0\" # Which version of the OpenAPI/Swagger specification we are following info: # Primarily for consumption by documentation generation tools title: My Service version: 0.1.0 host: localhost:1234 # Default host (and optional port) to connect to for generated clients schemes: - http paths: # All HTTP paths are direct children of the `paths` field /user/{id}: # Paths can have variable patterns in paths get: # HTTP method operationId: getUser # Friendly name, ends up as the function name (in clients and servers) x-jvm-package: users # Relative package for this client to live in. For convenience, the # last package parameter is turned into a class name for clients and # servers. In this case, `UsersClient`. parameters: # All parameters (including path parameters) are listed here. - name: id # The field name (case matters!), used to both identify the correct # field to match, as well as generate a best-guess idiomatic Scala # parameter name. in: path # Where to look for the parameter description: The ID of the user # The optional `description` parameter is not used in guardrail, # but is useful for providing a detailed explanation on what is # expected as a value for the parameter. For example: # `description: User IDs are strings comprised of the concatenation # of the two upper-case letters ID and a UUID stripped of any dashes # i.e. ID4d9b1c54e4664c9d92aba94151a7f59f` required: true # Required fields cannot be missing. `required: false` fields are # represented as `Option[T]` type: string # One of the primitive types supported in the OpenAPI specification. # https://github.com/OAI/OpenAPI-Specification/blob/master/versions/3.0.1.md#dataTypes x-scala-type: CustomString # Escape hatch to explicitly introduce a custom type. This is an # advanced technique to introduce completely custom # marshalling/unmarshalling/validation logic. Keep in mind, everyone # else will just see a plain string! responses: # All response codes that are possible are listed here 200: # Each HTTP status code is mapped to the corresponding textual # representation in guardrail-generated servers. schema: # The optional `schema` parameter describes what's possible to return # as the body of a response $ref: '#/definitions/User' # In the generated `UsersHandler` `getUser` function, we can call # `respond.OK(user)`, where `user: definitions.User` 404: # We must represent our failure cases as well, otherwise we can # never express failure! description: Not found # The optional `description` parameter is not used in guardrail, # but is useful here as an indicator that we don't have a response # body for `404 Not Found` responses. definitions: # All non-primitive structures are defined inside `definitions` User: # This identifies a symbolic structure name. Not all names are # translated into classes when rendered, depending on whether they # identify classes with structure, or defer to standard classes # like `Vector` for `type: array`. type: object # will generate a `User` case class in the `definitions` package required: # A list of which parameters are required. This is enforced for # clients by having non-optional parameters, and for servers by # ensuring all submitted data to the endpoint validates the schema # before getting to your `Handler` function. - id # These names must match the `properties` names exactly - user_addresses properties: # `object`s are permitted to have `properties`. These are translated # into fields in the generated case classes. id: # Case matters for `properties`! A heuristic determines whether it's # possible to translate a property name into a unique, non-reserved # camelCase identifier. type: string # One of the primitive types supported in the OpenAPI specification. # https://github.com/OAI/OpenAPI-Specification/blob/master/versions/3.0.1.md#dataTypes user_addresses: # Similar to `id`, though `user_addresses` can be safely transformed into # `userAddress`, so this is done to expose idiomatic Scala. The underlying # marshallers and unmarshallers maintain this mapping for you though, # so no chance of protocol violations. $ref: '#/definitions/UserAddresses' # Ensures that the type of `userAddress` will be `Vector[UserAddress]` UserAddresses: type: array items: # `items` is a special key for `type: array`, identifying the structure of the # sequence members $ref: '#/definitions/UserAddress' # Primitive types could be listed here, but as we're referring to another class, # we need to explicitly use a `$ref`. This may change in the future, # see https://github.com/twilio/guardrail/issues/76 UserAddress: type: object properties: line1: type: string line2: type: string line3: type: string Prev: Installation Next: Generating a Server"
    } ,    
    {
      "title": "Sample API Specification - akka-http - scala - guardrail",
      "url": "/./docs/scala/akka-http/sample-api-specification.html",
      "content": "Sample API specification The following is a complete, annotated OpenAPI specification file: (guardrail extensions are documented in guardrail Extensions) swagger: \"2.0\" # Which version of the OpenAPI/Swagger specification we are following info: # Primarily for consumption by documentation generation tools title: My Service version: 0.1.0 host: localhost:1234 # Default host (and optional port) to connect to for generated clients schemes: - http paths: # All HTTP paths are direct children of the `paths` field /user/{id}: # Paths can have variable patterns in paths get: # HTTP method operationId: getUser # Friendly name, ends up as the function name (in clients and servers) x-jvm-package: users # Relative package for this client to live in. For convenience, the # last package parameter is turned into a class name for clients and # servers. In this case, `UsersClient`. parameters: # All parameters (including path parameters) are listed here. - name: id # The field name (case matters!), used to both identify the correct # field to match, as well as generate a best-guess idiomatic Scala # parameter name. in: path # Where to look for the parameter description: The ID of the user # The optional `description` parameter is not used in guardrail, # but is useful for providing a detailed explanation on what is # expected as a value for the parameter. For example: # `description: User IDs are strings comprised of the concatenation # of the two upper-case letters ID and a UUID stripped of any dashes # i.e. ID4d9b1c54e4664c9d92aba94151a7f59f` required: true # Required fields cannot be missing. `required: false` fields are # represented as `Option[T]` type: string # One of the primitive types supported in the OpenAPI specification. # https://github.com/OAI/OpenAPI-Specification/blob/master/versions/3.0.1.md#dataTypes x-scala-type: CustomString # Escape hatch to explicitly introduce a custom type. This is an # advanced technique to introduce completely custom # marshalling/unmarshalling/validation logic. Keep in mind, everyone # else will just see a plain string! responses: # All response codes that are possible are listed here 200: # Each HTTP status code is mapped to the corresponding textual # representation in guardrail-generated servers. schema: # The optional `schema` parameter describes what's possible to return # as the body of a response $ref: '#/definitions/User' # In the generated `UsersHandler` `getUser` function, we can call # `respond.OK(user)`, where `user: definitions.User` 404: # We must represent our failure cases as well, otherwise we can # never express failure! description: Not found # The optional `description` parameter is not used in guardrail, # but is useful here as an indicator that we don't have a response # body for `404 Not Found` responses. definitions: # All non-primitive structures are defined inside `definitions` User: # This identifies a symbolic structure name. Not all names are # translated into classes when rendered, depending on whether they # identify classes with structure, or defer to standard classes # like `Vector` for `type: array`. type: object # will generate a `User` case class in the `definitions` package required: # A list of which parameters are required. This is enforced for # clients by having non-optional parameters, and for servers by # ensuring all submitted data to the endpoint validates the schema # before getting to your `Handler` function. - id # These names must match the `properties` names exactly - user_addresses properties: # `object`s are permitted to have `properties`. These are translated # into fields in the generated case classes. id: # Case matters for `properties`! A heuristic determines whether it's # possible to translate a property name into a unique, non-reserved # camelCase identifier. type: string # One of the primitive types supported in the OpenAPI specification. # https://github.com/OAI/OpenAPI-Specification/blob/master/versions/3.0.1.md#dataTypes user_addresses: # Similar to `id`, though `user_addresses` can be safely transformed into # `userAddress`, so this is done to expose idiomatic Scala. The underlying # marshallers and unmarshallers maintain this mapping for you though, # so no chance of protocol violations. $ref: '#/definitions/UserAddresses' # Ensures that the type of `userAddress` will be `Vector[UserAddress]` UserAddresses: type: array items: # `items` is a special key for `type: array`, identifying the structure of the # sequence members $ref: '#/definitions/UserAddress' # Primitive types could be listed here, but as we're referring to another class, # we need to explicitly use a `$ref`. This may change in the future, # see https://github.com/guardrail-dev/guardrail/issues/76 UserAddress: type: object properties: line1: type: string line2: type: string line3: type: string Prev: Installation Next: Generating a Server"
    } ,      
    {
      "title": "What is guardrail? - java - dropwizard - guardrail",
      "url": "/./docs/java/dropwizard/what-is-guardrail.html",
      "content": "What is guardrail? guardrail is a code generation tool, capable of reading from OpenAPI/Swagger specification files and generating Java source code for HTTP clients and backend frameworks like Dropwizard and Sprint MVC. guardrail has three primary goals: Documentation: Single point of truth for the interface to a software system Better Servers: Unexpected API changes surface as compiler errors via server routing layer code generation Better Clients: Fewer binary dependencies via client library code generation Describing software is tricky. Incomplete specifications, slippage between specification and implementation, or even additional semantics of infrastructure that aren’t easily communicated through static documents; these are only a few challenges you’ll face when attempting to write a specification for your API. A reasonable question you may be asking is what motivations are there for going through these cumbersome and often frustrating tasks? We’ll investigate some answers to this question in the following sections. Single Point of Truth By describing the shape of an API statically, there are far fewer variables to worry about. HTTP is a very flexible protocol, with many features. By constraining that protocol to a subset that expresses the interface to our server (or service, or microservice), we drastically reduce the burden of handling the entirety of HTTP to the core terms of our API. Focus on semantics of APIs once the basics (routing, data validation) are figured out. A secondary benefit of static specifications lies in tooling. Hand-written routing logic can hide security holes, miss best practices, and obscure intent if written incorrectly. This problem is multipled across as many different languages as are supported inside any given company, manifesting as wasted effort implementing the same feature in different languages, or a bug that only occurs 10 percent of the time due to a buggy golang client. Attempting to derive what the attack surface of a server is from the implementation is often the job of entire teams in large companies, and even that may not be enough. Conversely, with a static specification, those teams can build intelligent traffic analysis tools to detect anomalies or intentionally malicious clients built to inject bad data to find bugs. Unexpected API changes are compiler errors Once we have a specification, generating traits (or abstract classes) with unimplemented members gives us another powerful tool: New or changed parameters become compiler errors. After constraining our vocabulary to a subset of HTTP that serves our business need, even saying “This parameter is optional” forces us to contend with the sudden appearance of Optional&lt;T&gt; parameters in our generated Handler methods. Once specified, -Werror helpfully points out that we’ve forgotten to reflect this most recent change in our tests. A win on both fronts! Fewer binary dependencies Traditionally written and maintained client libraries invariably accumulate cruft. In many cases, this is intended to be helpful: papering over a poorly designed API by providing custom logic, renaming parameters to be more convenient, or including properly configured HTTP clients that express retry and backoff semantics the library author provided based on the business requirements known at the time of writing. Altering the shape of an API by providing a thick HTTP client reduces the shared terminology between service maintainers and their consumers, or even between consumers coming from different languages. Additionally, by hardcoding even a well-behaved HTTP client into a client library, now consumers are forced to work around that dependency. This may manifest as learning how to use and configure a brand new HTTP client under time pressure, or writing and maintaining brittle Application Binary Interface (ABI)-compatible adapter layers that attempt to use the configuration already present in the rest of the codebase. Once these bespoke HTTP client configurations are built, both they and their dependencies are now added to the grab bag of dependency versions that must be maintained through the life of any given piece of infrastructure. This presents hidden barriers for upgrading all dependencies, as the possibility of transitive dependency conflicts increase as dependency trees become deeper. Next: Installation"
    } ,    
    {
      "title": "What is guardrail? - http4s - scala - guardrail",
      "url": "/./docs/scala/http4s/what-is-guardrail.html",
      "content": "What is guardrail? guardrail is a code generation tool, capable of reading from OpenAPI/Swagger specification files and generating Scala source code, primarily targeting the akka-http and http4s web frameworks, using circe for JSON encoding/decoding. guardrail has three primary goals: Documentation: Single point of truth for the interface to a software system Better Servers: Unexpected API changes surface as compiler errors via server routing layer code generation Better Clients: Fewer binary dependencies via client library code generation Describing software is tricky. Incomplete specifications, slippage between specification and implementation, or even additional semantics of infrastructure that aren’t easily communicated through static documents; these are only a few challenges you’ll face when attempting to write a specification for your API. A reasonable question you may be asking is what motivations are there for going through these cumbersome and often frustrating tasks? We’ll investigate some answers to this question in the following sections. Single Point of Truth By describing the shape of an API statically, there are far fewer variables to worry about. HTTP is a very flexible protocol, with many features. By constraining that protocol to a subset that expresses the interface to our server (or service, or microservice), we drastically reduce the burden of handling the entirety of HTTP to the core terms of our API. Focus on semantics of APIs once the basics (routing, data validation) are figured out. A secondary benefit of static specifications lies in tooling. Hand-written routing logic can hide security holes, miss best practices, and obscure intent if written incorrectly. This problem is multipled across as many different languages as are supported inside any given company, manifesting as wasted effort implementing the same feature in different languages, or a bug that only occurs 10 percent of the time due to a buggy golang client. Attempting to derive what the attack surface of a server is from the implementation is often the job of entire teams in large companies, and even that may not be enough. Conversely, with a static specification, those teams can build intelligent traffic analysis tools to detect anomalies or intentionally malicious clients built to inject bad data to find bugs. Unexpected API changes are compiler errors Once we have a specification, generating traits (or abstract classes) with unimplemented members gives us another powerful tool: New or changed parameters become compiler errors. After constraining our vocabulary to a subset of HTTP that serves our business need, even saying “This parameter is optional” forces us to contend with the sudden appearance of Option[T] parameters in our generated Handler methods. Once specified, -Ywarn-unused helpfully points out that we’ve forgotten to reflect this most recent change in our tests. A win on both fronts! Fewer binary dependencies Traditionally written and maintained client libraries invariably accumulate cruft. In many cases, this is intended to be helpful: papering over a poorly designed API by providing custom logic, renaming parameters to be more convenient, or including properly configured HTTP clients that express retry and backoff semantics the library author provided based on the business requirements known at the time of writing. Altering the shape of an API by providing a thick HTTP client reduces the shared terminology between service maintainers and their consumers, or even between consumers coming from different languages. Additionally, by hardcoding even a well-behaved HTTP client into a client library, now consumers are forced to work around that dependency. This may manifest as learning how to use and configure a brand new HTTP client under time pressure, or writing and maintaining brittle Application Binary Interface (ABI)-compatible adapter layers that attempt to use the configuration already present in the rest of the codebase. Once these bespoke HTTP client configurations are built, both they and their dependencies are now added to the grab bag of dependency versions that must be maintained through the life of any given piece of infrastructure. This presents hidden barriers for upgrading all dependencies, as the possibility of transitive dependency conflicts increase as dependency trees become deeper. Next: Installation"
    } ,    
    {
      "title": "What is guardrail? - akka-http - scala - guardrail",
      "url": "/./docs/scala/akka-http/what-is-guardrail.html",
      "content": "What is guardrail? guardrail is a code generation tool, capable of reading from OpenAPI/Swagger specification files and generating Scala source code, primarily targeting the akka-http and http4s web frameworks, using circe for JSON encoding/decoding. guardrail has three primary goals: Documentation: Single point of truth for the interface to a software system Better Servers: Unexpected API changes surface as compiler errors via server routing layer code generation Better Clients: Fewer binary dependencies via client library code generation Describing software is tricky. Incomplete specifications, slippage between specification and implementation, or even additional semantics of infrastructure that aren’t easily communicated through static documents; these are only a few challenges you’ll face when attempting to write a specification for your API. A reasonable question you may be asking is what motivations are there for going through these cumbersome and often frustrating tasks? We’ll investigate some answers to this question in the following sections. Single Point of Truth By describing the shape of an API statically, there are far fewer variables to worry about. HTTP is a very flexible protocol, with many features. By constraining that protocol to a subset that expresses the interface to our server (or service, or microservice), we drastically reduce the burden of handling the entirety of HTTP to the core terms of our API. Focus on semantics of APIs once the basics (routing, data validation) are figured out. A secondary benefit of static specifications lies in tooling. Hand-written routing logic can hide security holes, miss best practices, and obscure intent if written incorrectly. This problem is multipled across as many different languages as are supported inside any given company, manifesting as wasted effort implementing the same feature in different languages, or a bug that only occurs 10 percent of the time due to a buggy golang client. Attempting to derive what the attack surface of a server is from the implementation is often the job of entire teams in large companies, and even that may not be enough. Conversely, with a static specification, those teams can build intelligent traffic analysis tools to detect anomalies or intentionally malicious clients built to inject bad data to find bugs. Unexpected API changes are compiler errors Once we have a specification, generating traits (or abstract classes) with unimplemented members gives us another powerful tool: New or changed parameters become compiler errors. After constraining our vocabulary to a subset of HTTP that serves our business need, even saying “This parameter is optional” forces us to contend with the sudden appearance of Option[T] parameters in our generated Handler methods. Once specified, -Ywarn-unused helpfully points out that we’ve forgotten to reflect this most recent change in our tests. A win on both fronts! Fewer binary dependencies Traditionally written and maintained client libraries invariably accumulate cruft. In many cases, this is intended to be helpful: papering over a poorly designed API by providing custom logic, renaming parameters to be more convenient, or including properly configured HTTP clients that express retry and backoff semantics the library author provided based on the business requirements known at the time of writing. Altering the shape of an API by providing a thick HTTP client reduces the shared terminology between service maintainers and their consumers, or even between consumers coming from different languages. Additionally, by hardcoding even a well-behaved HTTP client into a client library, now consumers are forced to work around that dependency. This may manifest as learning how to use and configure a brand new HTTP client under time pressure, or writing and maintaining brittle Application Binary Interface (ABI)-compatible adapter layers that attempt to use the configuration already present in the rest of the codebase. Once these bespoke HTTP client configurations are built, both they and their dependencies are now added to the grab bag of dependency versions that must be maintained through the life of any given piece of infrastructure. This presents hidden barriers for upgrading all dependencies, as the possibility of transitive dependency conflicts increase as dependency trees become deeper. Next: Installation"
    }    
  ];

  idx = lunr(function () {
    this.ref("title");
    this.field("content");

    docs.forEach(function (doc) {
      this.add(doc);
    }, this);
  });

  docs.forEach(function (doc) {
    docMap.set(doc.title, doc.url);
  });
}

// The onkeypress handler for search functionality
function searchOnKeyDown(e) {
  const keyCode = e.keyCode;
  const parent = e.target.parentElement;
  const isSearchBar = e.target.id === "search-bar";
  const isSearchResult = parent ? parent.id.startsWith("result-") : false;
  const isSearchBarOrResult = isSearchBar || isSearchResult;

  if (keyCode === 40 && isSearchBarOrResult) {
    // On 'down', try to navigate down the search results
    e.preventDefault();
    e.stopPropagation();
    selectDown(e);
  } else if (keyCode === 38 && isSearchBarOrResult) {
    // On 'up', try to navigate up the search results
    e.preventDefault();
    e.stopPropagation();
    selectUp(e);
  } else if (keyCode === 27 && isSearchBarOrResult) {
    // On 'ESC', close the search dropdown
    e.preventDefault();
    e.stopPropagation();
    closeDropdownSearch(e);
  }
}

// Search is only done on key-up so that the search terms are properly propagated
function searchOnKeyUp(e) {
  // Filter out up, down, esc keys
  const keyCode = e.keyCode;
  const cannotBe = [40, 38, 27];
  const isSearchBar = e.target.id === "search-bar";
  const keyIsNotWrong = !cannotBe.includes(keyCode);
  if (isSearchBar && keyIsNotWrong) {
    // Try to run a search
    runSearch(e);
  }
}

// Move the cursor up the search list
function selectUp(e) {
  if (e.target.parentElement.id.startsWith("result-")) {
    const index = parseInt(e.target.parentElement.id.substring(7));
    if (!isNaN(index) && (index > 0)) {
      const nextIndexStr = "result-" + (index - 1);
      const querySel = "li[id$='" + nextIndexStr + "'";
      const nextResult = document.querySelector(querySel);
      if (nextResult) {
        nextResult.firstChild.focus();
      }
    }
  }
}

// Move the cursor down the search list
function selectDown(e) {
  if (e.target.id === "search-bar") {
    const firstResult = document.querySelector("li[id$='result-0']");
    if (firstResult) {
      firstResult.firstChild.focus();
    }
  } else if (e.target.parentElement.id.startsWith("result-")) {
    const index = parseInt(e.target.parentElement.id.substring(7));
    if (!isNaN(index)) {
      const nextIndexStr = "result-" + (index + 1);
      const querySel = "li[id$='" + nextIndexStr + "'";
      const nextResult = document.querySelector(querySel);
      if (nextResult) {
        nextResult.firstChild.focus();
      }
    }
  }
}

// Search for whatever the user has typed so far
function runSearch(e) {
  if (e.target.value === "") {
    // On empty string, remove all search results
    // Otherwise this may show all results as everything is a "match"
    applySearchResults([]);
  } else {
    const tokens = e.target.value.split(" ");
    const moddedTokens = tokens.map(function (token) {
      // "*" + token + "*"
      return token;
    })
    const searchTerm = moddedTokens.join(" ");
    const searchResults = idx.search(searchTerm);
    const mapResults = searchResults.map(function (result) {
      const resultUrl = docMap.get(result.ref);
      return { name: result.ref, url: resultUrl };
    })

    applySearchResults(mapResults);
  }

}

// After a search, modify the search dropdown to contain the search results
function applySearchResults(results) {
  const dropdown = document.querySelector("div[id$='search-dropdown'] > .dropdown-content.show");
  if (dropdown) {
    //Remove each child
    while (dropdown.firstChild) {
      dropdown.removeChild(dropdown.firstChild);
    }

    //Add each result as an element in the list
    results.forEach(function (result, i) {
      const elem = document.createElement("li");
      elem.setAttribute("class", "dropdown-item");
      elem.setAttribute("id", "result-" + i);

      const elemLink = document.createElement("a");
      elemLink.setAttribute("title", result.name);
      elemLink.setAttribute("href", result.url);
      elemLink.setAttribute("class", "dropdown-item-link");

      const elemLinkText = document.createElement("span");
      elemLinkText.setAttribute("class", "dropdown-item-link-text");
      elemLinkText.innerHTML = result.name;

      elemLink.appendChild(elemLinkText);
      elem.appendChild(elemLink);
      dropdown.appendChild(elem);
    });
  }
}

// Close the dropdown if the user clicks (only) outside of it
function closeDropdownSearch(e) {
  // Check if where we're clicking is the search dropdown
  if (e.target.id !== "search-bar") {
    const dropdown = document.querySelector("div[id$='search-dropdown'] > .dropdown-content.show");
    if (dropdown) {
      dropdown.classList.remove("show");
      document.documentElement.removeEventListener("click", closeDropdownSearch);
    }
  }
}
