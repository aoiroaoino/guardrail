## Generating a Server

guardrail-generated servers come in two parts: a `Resource` and a `Handler`. The `Resource` contains all the routing logic, accepting a `Handler` as an argument to the `route` function in order to provide an HTTP service in whichever supported HTTP framework you're hosting your service in.

The following is an example from the [http4s](https://github.com/http4s/http4s) server generator:

```scala

// The `Handler` trait is fully abstracted from the underlying http framework. As a result, with the exception of some
// structural alterations (`F[_]` instead of `Future[_]` as the return type) the same handlers can be used with
// different `Resource` implementations from different framework generators. This permits greater compatibility between
// different frameworks without changing your business logic.
  
trait UserHandler[F[_]] {
  def createUser(respond: UserResource.CreateUserResponse.type)(body: definitions.User): F[UserResource.CreateUserResponse]
  def createUsersWithArrayInput(respond: UserResource.CreateUsersWithArrayInputResponse.type)(body: Vector[definitions.User]): F[UserResource.CreateUsersWithArrayInputResponse]
  def createUsersWithListInput(respond: UserResource.CreateUsersWithListInputResponse.type)(body: Vector[definitions.User]): F[UserResource.CreateUsersWithListInputResponse]
  def loginUser(respond: UserResource.LoginUserResponse.type)(username: String, password: String): F[UserResource.LoginUserResponse]
  def logoutUser(respond: UserResource.LogoutUserResponse.type)(): F[UserResource.LogoutUserResponse]
  def getUserByName(respond: UserResource.GetUserByNameResponse.type)(username: String): F[UserResource.GetUserByNameResponse]
  def updateUser(respond: UserResource.UpdateUserResponse.type)(username: String, body: definitions.User): F[UserResource.UpdateUserResponse]
  def deleteUser(respond: UserResource.DeleteUserResponse.type)(username: String): F[UserResource.DeleteUserResponse]
}

class UserResource[F[_]](mapRoute: (String, Request[F], F[Response[F]]) => F[Response[F]] = (_: String, _: Request[F], r: F[Response[F]]) => r)(implicit F: Async[F]) extends Http4sDsl[F] with CirceInstances {
  def routes(handler: UserHandler[F]): HttpRoutes[F] = HttpRoutes.of {
    {
      case req @ POST -> Root / "v2" / "user" =>
        mapRoute("createUser", req, {
          req.attemptAs(createUserDecoder).foldF(err => err.cause match {
            case Some(circeErr: io.circe.DecodingFailure) =>
              Response[F](status = org.http4s.Status.UnprocessableEntity, body = stringEncoder.toEntity("The request body was invalid. " + circeErr.message + ": " + circeErr.history.mkString(", ")).body).pure[F]
            case _ =>
              err.toHttpResponse[F](req.httpVersion).pure[F]
          }, body => handler.createUser(CreateUserResponse)(body) flatMap ({
            case CreateUserResponse.Ok =>
              F.pure(Response[F](status = org.http4s.Status.Ok))
          }))
        })
      case req @ POST -> Root / "v2" / "user" / "createWithArray" =>
        mapRoute("createUsersWithArrayInput", req, {
          req.attemptAs(createUsersWithArrayInputDecoder).foldF(err => err.cause match {
            case Some(circeErr: io.circe.DecodingFailure) =>
              Response[F](status = org.http4s.Status.UnprocessableEntity, body = stringEncoder.toEntity("The request body was invalid. " + circeErr.message + ": " + circeErr.history.mkString(", ")).body).pure[F]
            case _ =>
              err.toHttpResponse[F](req.httpVersion).pure[F]
          }, body => handler.createUsersWithArrayInput(CreateUsersWithArrayInputResponse)(body) flatMap ({
            case CreateUsersWithArrayInputResponse.Ok =>
              F.pure(Response[F](status = org.http4s.Status.Ok))
          }))
        })
    }
  }
  `...`
}
```

As all parameters are provided as arguments to the function stubs in the trait, there's no concern of forgetting to extract a query string parameter or introducing a typo in a form parameter name.

The routes and resources generated by guardrail can be hooked up into your HTTP4s server like so:

```scala
import org.http4s.ember.server.EmberServerBuilder

class UserImpl extends UserHandler[IO] { /* Your code here */ }
val userHandler: UserHandler[IO] = new UserImpl
val usersService = new UsersResource[IO]().routes(userHandler)
val httpApp = usersService.orNotFound

// Same basic server setup as in the http4s quickstart
EmberServerBuilder.default[IO]
  .withHttpApp(httpApp)
  .build
  .use(_ => IO.never)
  .as(ExitCode.Success)
```

(See it in action: [guardrail-dev/guardrail-sample-http4s](https://github.com/guardrail-dev/guardrail-sample-http4s), [guardrail-dev/guardrail-sample-sbt-http4s-zio](https://github.com/guardrail-dev/guardrail-sample-sbt-http4s-zio))

Generating clients
==================

As we've seen in [Generating a Server](generating-a-server), guardrail-generated servers establish a mapping between our business logic and a cordoned off subset of HTTP. This permits us to focus on our business logic, without getting overloaded with the complexities of managing such a large protocol. The same is true with guardrail generated HTTP Clients: from a consumer's standpoint, HTTP calls should look like regular function calls, accepting domain-specific arguments and producing domain-specific results.

By generating minimal clients that only have enough business knowledge to map domain types to and from HTTP, opportunities for logical errors are effectively removed. While this does not eliminate logical errors entirely, establishing a firm boundary between the underlying protocol and hand-written code drastically reduces the scope of possible bugs.

The following is an example from the [http4s](https://github.com/http4s/http4s) client generator:

```scala
// Two constructors are provided, one accepting the `httpClient` and `Async`
// implicitly, the other accepting an explicit `httpClient`, but still
// accepting the `Async` implicitly
  
object UserClient {
  def apply[F[_]](host: String)(implicit F: Async[F], httpClient: Http4sClient[F]): UserClient[F] = new UserClient[F](host = host)(F = F, httpClient = httpClient)
  def httpClient[F[_]](httpClient: Http4sClient[F], host: String)(implicit F: Async[F]): UserClient[F] = new UserClient[F](host = host)(F = F, httpClient = httpClient)
}

class UserClient[F[_]](host: String)(implicit F: Async[F], httpClient: Http4sClient[F]) {
  val basePath: String = "/v2"
  def createUser(body: definitions.User, headers: List[Header.ToRaw] = List.empty): F[CreateUserResponse] = {
    val allHeaders: List[org.http4s.Header.ToRaw] = List.empty[Header.ToRaw] ++ headers ++ List[Option[Header.ToRaw]]().flatten
    val req = Request[F](method = Method.POST, uri = Uri.unsafeFromString(host + basePath + "/user"), headers = Headers(allHeaders)).withEntity(body)(createUserEncoder)
    httpClient.run(req).use({
      case _root_.org.http4s.Status.Ok(_) =>
        F.pure(CreateUserResponse.Ok): F[CreateUserResponse]
      case resp =>
        F.raiseError[CreateUserResponse](UnexpectedStatus(resp.status, Method.POST, req.uri))
    })
  }
  def createUsersWithArrayInput(body: Vector[definitions.User], headers: List[Header.ToRaw] = List.empty): F[CreateUsersWithArrayInputResponse] = ???
  def createUsersWithListInput(body: Vector[definitions.User], headers: List[Header.ToRaw] = List.empty): F[CreateUsersWithListInputResponse] = ???
  def loginUser(username: String, password: String, headers: List[Header.ToRaw] = List.empty): F[LoginUserResponse] = ???
  def logoutUser(headers: List[Header.ToRaw] = List.empty): F[LogoutUserResponse] = ???
  def getUserByName(username: String, headers: List[Header.ToRaw] = List.empty): F[GetUserByNameResponse] = ???
  def updateUser(username: String, body: definitions.User, headers: List[Header.ToRaw] = List.empty): F[UpdateUserResponse] = ???
  def deleteUser(username: String, headers: List[Header.ToRaw] = List.empty): F[DeleteUserResponse] = ???
}
```

(See it in action: [guardrail-dev/guardrail-sample-http4s](https://github.com/guardrail-dev/guardrail-sample-http4s), [guardrail-dev/guardrail-sample-sbt-http4s-zio](https://github.com/guardrail-dev/guardrail-sample-sbt-http4s-zio))

Separation of protocol-concerns from API-level concerns
-------------------------------------------------------

As guardrail clients are built on top of any Http4s client type, client configuration is done the same way as you are
already familiar with when using Http4s.

Check out the docs for [Http4s Clients](https://http4s.org/v0.23/client/).

<span style="float: left">[Prev: Generating a Server](generating-a-server)</span>
